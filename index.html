<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SVG Watches</title>
    <style>
    html, body{
        margin: 0;
        padding: 0;
    }
    body{
        background: #3B3B3B url(back.png);
        overflow: hidden;
        cursor: default;
    }
    #svg{
		background: url(loader.gif) 50% 50% no-repeat;
    }
    </style>
    <link rel="apple-touch-icon" href="icon.png"/>
</head>
<body>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
        viewBox="0 0 1000 1000"
        preserveAspectRatio="xMidYMid meet" id="svg">
    <defs>
        <radialGradient id="touchGradient" cx="50%" cy="50%" r="50%">
            <stop stop-color="#282828" offset="40%"/>
            <stop stop-color="#323232" offset="60%"/>
            <stop stop-color="#282828" offset="75%"/>
        </radialGradient>
        <g id="touchTexture" fill="#eee" fill-opacity="0.1">
            <rect class="touch-texture-rect" x="260" y="-4" width="8" height="8"></rect>
            <rect class="touch-texture-rect" x="280" y="-4" width="8" height="8"></rect>
            <rect class="touch-texture-rect" x="300" y="-4" width="8" height="8"></rect>
        </g>
        <polygon id="markPrototype" points="375 10, 375 -10, 470 -13, 470 13" class="mark" />
        <polygon id="smallMarkPrototype" points="410 9, 410 -9, 470 -11, 470 11" class="smallmark" />
        <filter id="drop-shadow"> 
            <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
            <feOffset in="blur" dx="1" dy="0" result="offsetBlur"/>
            <feMerge>
                <feMergeNode in="offsetBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
        <style type="text/css"><![CDATA[
        .clockface-cover{
            fill: url(#touchGradient);
        }
        .arrows { 
            fill: #eee; 
        }
        .seconds{
            fill: red;
        }
        .seconds-nail{
            fill: #eee;
            stroke-width: 3px;
            stroke: #444;
        }
        .shadow{
            filter: url(#drop-shadow);
        }
        .service-button{
            fill: #777; 
        }
        .mark, .smallmark{
            fill: "#eee";
        }
        .speed-time{
            fill: #eee;
            text-anchor: middle;
            font-size: 140px;
        }
        .time-hint{
            fill: #aaa;
            text-anchor: middle;
            font-size: 50px;
            font-weight: bold;      
        }
        .speed-time-cover{

        }
        .clockface{
        	opacity: 0;
        }
        .clockface.active{
			-webkit-transition: opacity 0.5s linear;
			opacity: 1;
        }
        ]]></style>
    </defs>
    <g transform="translate(500, 500)">
        <g id="clockface" class="clockface">
        	<g>
	       	    <g id="clearButton" transform="translate(400, -400)">
			        <circle cx="0" cy="0" r="50" class="service-button shadow" />
			        <path transform="scale(2.5), translate(-15, -15)" d="M25.947,11.14c0-5.174-3.979-9.406-10.613-9.406c-6.633,0-10.282,4.232-10.282,9.406c0,5.174,1.459,4.511,1.459,7.43c0,1.095-1.061,0.564-1.061,2.919c0,2.587,3.615,2.223,4.677,3.283c1.061,1.062,0.961,3.019,0.961,3.019s0.199,0.796,0.564,0.563c0,0,0.232,0.564,0.498,0.232c0,0,0.265,0.563,0.531,0.1c0,0,0.265,0.631,0.696,0.166c0,0,0.431,0.63,0.929,0.133c0,0,0.564,0.53,1.194,0.133c0.63,0.397,1.194-0.133,1.194-0.133c0.497,0.497,0.929-0.133,0.929-0.133c0.432,0.465,0.695-0.166,0.695-0.166c0.268,0.464,0.531-0.1,0.531-0.1c0.266,0.332,0.498-0.232,0.498-0.232c0.365,0.232,0.564-0.563,0.564-0.563s-0.1-1.957,0.961-3.019c1.062-1.061,4.676-0.696,4.676-3.283c0-2.354-1.061-1.824-1.061-2.919C24.488,15.651,25.947,16.314,25.947,11.14zM10.333,20.992c-1.783,0.285-2.59-0.215-2.785-1.492c-0.508-3.328,2.555-3.866,4.079-3.683c0.731,0.088,1.99,0.862,1.99,1.825C13.617,20.229,11.992,20.727,10.333,20.992zM16.461,25.303c-0.331,0-0.862-0.431-0.895-1.227c-0.033,0.796-0.63,1.227-0.961,1.227c-0.332,0-0.83-0.331-0.863-1.127c-0.033-0.796,1.028-4.013,1.792-4.013c0.762,0,1.824,3.217,1.791,4.013S16.794,25.303,16.461,25.303zM23.361,19.5c-0.195,1.277-1.004,1.777-2.787,1.492c-1.658-0.266-3.283-0.763-3.283-3.35c0-0.963,1.258-1.737,1.99-1.825C20.805,15.634,23.869,16.172,23.361,19.5z" fill="#eee"/>
			    </g>
			    <g id="reloadButton" transform="translate(-400, 400)">
			        <circle cx="0" cy="0" r="50" class="service-button shadow" />
			        <path transform="scale(2.5), translate(-15, -15)" d="M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z" fill="#eee"/>
			    </g>
			</g>
            <circle cx="0" cy="0" r="485" class="clockface-cover" />
            <g id="touchTextureBlock"></g>
            <g id="clockmarkslive"></g>
            <g id="hours">
                <rect class="shadow arrows" x="-100" y="-15" width="350" height="30"></rect>
            </g>
            <g id="minutes">
                <rect class="shadow arrows" x="-100" y="-15" width="480" height="30"></rect>
            </g>
            <g id="seconds" class="shadow arrows seconds">
                <rect x="-100" y="-5" width="490" height="10"></rect>
                <circle cx="0" cy="0" r="13"/>
                <circle cx="0" cy="0" r="5" class="seconds-nail" />
            </g>
            <g id="speedTimeBlock" display="none">
                <polygon id="speedTimeMarker" points="420 0, 495 -25, 495 25" class="shadow" />
                <circle id="speedTimeCover" cx="0" cy="0" r="200" class="speed-time-cover" />
                <text id="speedTime" x="0" y="40" class="speed-time"></text>
            </g>
        </g>
    </g>
</svg>
<style type="text/css">
.visible{
	display: block;
}
.invisible{
	display: none;
}
.info-popup{
	position: absolute;
	top: 0;
	width: 100%;
}
.info-popup-inner{
	padding: 20px;
	background: #eee;
	max-width: 480px;
	margin: 0 auto;
	box-shadow: 0 3px 6px 3px #333;
}
.input-block{
	border-radius: 5px;
	padding: 5px;
	border: 1px solid #aaa;	
}
.form-input{
    padding: 0;
    width: 100%;
	height: 3.7em;
    border: 0;
    background: #efefef;
	resize: none;
}
.text{
    color: #222;
    font-size: 20px;
    font-family: Georgia, Verdana;
}
.block{
    margin-bottom:10px;
}
.button{
    padding: 12px 10px;
    width: 98%;
    font-size: 20px;
}
.refuse-button{
    color: #777;
}
.time{
    font-size: 20px;
    font-weight: bold;
}
.buttons-box{
	width: 100%;
	border: 0;
	border-collapse:collapse;
}
.buttons-box td{
	padding: 0;
}
</style>
<div id="eventPrompt" class="invisible">
	<div class="info-popup">
		<div class="info-popup-inner">
			<form id="eventForm" method="post" action="">
			    <div id="setTime" class="time block"></div>
			    <div class="block input-block">
			        <textarea id="eventName" class="form-input text" rows="2" placeholder="Wazzap!"></textarea>
			    </div>
			    <table class="buttons-box">
			        <tr>
			            <td align="left" width="50%">
			                <input id="eventButtonRemove" type="button" class="text button refuse-button" name="remove" value="Remove">
			            </td>
			            <td align="right" width="50%">
			                <input id="eventButtonSet" type="submit" class="text button" name="submit" value="Set">
			            </td>
			        </tr>
			    </table>
			</form>
		</div>
	</div>
</div>
<script type="text/javascript">
function resizeSvg(){
    var svg = Element.find('svg');
    svg.attr({'width': window.innerWidth, 'height': window.innerHeight});
}

var orientationEvent = "onorientationchange" in window ? "orientationchange" : "resize";
window.addEventListener(orientationEvent, resizeSvg, false);
window.addEventListener('load', function(){
    var clock = new Clock();
    clock.start();	
}, false);
/****************************************************/

function Mark(id){
    this.update = new Date();
    this.time = new Date();
    
    if (id !== null){
        this.find(id);
    }
}

Mark.prototype = {
    id: null,

    checked: false,
    
    title: '',
    
    time: 0,
    
    update: 0,
    
    find: function(id){
        this.reset();
        this.id = id;
        
        var data = localStorage.getItem(id);
        if (data !== null){
            data = JSON.parse(data);
            if (typeof data == 'object'){
                if (data.checked !== null) this.checked = data.checked || false;
                if (data.title !== null) this.title = data.title + "";
                if (data.update !== null) this.update = new Date(data.update);
                if (data.time !== null) this.time = new Date(data.time);
            }
        }
    },
    
    reset: function(){
        this.id = null;
        this.checked = false;
        this.title = '';
        this.time = new Date();
    },
    
    remove: function(){
        localStorage.removeItem(this.id);
        this.reset();
    },
    
    save: function(){
        this.update = new Date();
        
        var data = {
            checked: this.checked || false,
            title: this.title + "",
            update: this.update.getTime(),
            time: this.time.getTime()
        };
        
        localStorage.setItem(this.id, JSON.stringify(data));
    }
}

/****************************************************/

function Angle(angle){
    this.angle = angle;
}

Angle.prototype = {
    angle: 0,

    get: function(){
        return this.angle;
    },
    
    set: function(angle){
        angle += "";
        this.angle = angle * 1;
    },
    
    add: function(angle){
        angle += "";
        this.angle += angle * 1;
    },
    
    normalize: function(){
        this.angle = this.normalized();
    },
    
    normalized: function(){
        var angle = this.angle;
        if (angle < 0) angle = 360 + angle % 360;
        if (angle >= 360) angle = angle % 360;
        
        return angle;
    },
    
    distance: function(angle){
        if (typeof angle !== "object") angle = new Angle(angle);

        var calcAngle = this.normalized() - angle.normalized();
        var isPositive = false;

        if (calcAngle >= 0){
            isPositive = calcAngle <= (360 - Angle.config.oldTimeShow);
            if (!isPositive) calcAngle = 360 - calcAngle;
        } else {
            isPositive = -calcAngle > Angle.config.oldTimeShow;
            if (isPositive) calcAngle += 360;
        }
        
        calcAngle = Math.abs(calcAngle);

        return new Angle(isPositive ? calcAngle : -calcAngle);
    },
    
    toTime: function(){
        var time = new Date();
        var hourAngle = Angle.fromTimeHour(time);
        var milliseconds = this.distance(hourAngle).toMilliseconds();
        return new Date(time.getTime() + milliseconds);
    },
    
    /**
     * 12 hours in 360 degrees
     */
    toMilliseconds: function(){
        return 12 * 60 * 60 * 1000 / 360 * this.angle;
    },
    
    toString: function(){
        return this.get();
    }
}

Angle.config = {
    startAngle: 270,
    oneHourAngle: 30,
    oneMinuteAngle: 6,
    oneSecondAngle: 6,
    oldTimeShow: 30
}

Angle.fromPoint = function(x1, x2, y1, y2){
    x2 = x2 - Math.floor(document.body.clientWidth / 2);
    y2 = y2 - Math.floor(document.body.clientHeight / 2);

    var angle = Math.atan2(x1-x2,y1-y2)*(180/Math.PI);
    angle += 90;
    if(angle < 0){
        angle = Math.abs(angle);
    } else {
        angle = 360 - angle;
    }
    return new Angle(angle);
}

Angle.fromTimeHour = function(time){
    var angle = new Angle(Angle.config.startAngle + Angle.config.oneHourAngle * (time.getHours() + time.getMinutes() / 60 + time.getSeconds() / 3600));
    angle.normalize();
    return angle;
}
    
Angle.fromTimeMinute = function(time){
    var angle = new Angle(Angle.config.startAngle + Angle.config.oneMinuteAngle * (time.getMinutes() + time.getSeconds() / 60));
    angle.normalize();
    return angle;
}

Angle.fromTimeSecond = function(time){
    var angle = new Angle(Angle.config.startAngle + Angle.config.oneSecondAngle * (time.getSeconds() + time.getMilliseconds() / 1000));
    angle.normalize();
    return angle;
}

/****************************************************/

function Element(node){
    if (!node) throw new Error("DOM element required");
    this.node = node;
}

Element.prototype = {
    getNode: function(){
        return this.node;
    },

    append: function(element){
        this.getNode().appendChild(element.getNode());
    },
    
    appendTo: function(element){
        element.getNode().appendChild(this.getNode());
    },
    
    attr: function(attr, value){
        if (typeof attr !== "object"){
            if (value === undefined){
                return this.getNode().getAttribute(attr);
            }
            
            var attrName = attr;
            attr = {};
            attr[attrName] = value;
        }
        
        for (var x in attr){
            var attrParts = x.split(':', 2);
            if (attrParts.length == 2 && attrParts[0] == 'xlink'){
                this.getNode().setAttributeNS(Element.xlinkNS, attrParts[1], attr[x]);
            } else {
                this.getNode().setAttributeNS(null, x, attr[x]);
            }
        }
    },
    
    html: function(html){
        this.getNode().innerHTML = html;
    },
    
    text: function(text){
        var textNode = document.createTextNode(text);
        
        var children = this.getNode().childNodes;
        while(children.length) {
            this.getNode().removeChild(children[0]);
        }
        this.getNode().appendChild(textNode);
    },
    
    val: function(value){
        if (value === undefined){
            return this.getNode().value;
        }
        this.getNode().value = value;
    },
    
    on: function(event, callback){
        event = "on" + event;
        this.getNode()[event] = callback;
    },
    
    transform: function(type){
        var args = Array.prototype.slice.call(arguments);
        var strArgs = args.slice(1).join(",");
        this.attr("transform", type + "(" + strArgs + ")");
    },
    
    animate: function(attr, value, duration){
        var cValue = this.attr(attr);
        var size = Math.abs(cValue - value);
        
        //@todo finish this function 
    }
}

Element.xmlNS = "http://www.w3.org/2000/svg";
Element.xlinkNS = "http://www.w3.org/1999/xlink";

Element.create = function(tag){
    var node = document.createElementNS(Element.xmlNS, tag);
    return new Element(node);
}

Element.use = function(id){
    var el = Element.create('use');
    el.attr("xlink:href", '#' + id);
    return el;
}

Element.find = function(id){
    var node = document.getElementById(id);
    if (!node) return false;
    
    return new Element(node);
}

/****************************************************/

function formatTime(date){
    var hours = date.getHours() + '';
    var minutes = date.getMinutes() + '';
    return (hours.length < 2 ? '0' : '') + hours + ':' + (minutes.length < 2 ? '0' : '') + minutes;
}

/****************************************************/

function getGradient(color1, color2, percent){
    
    function hexToRgb(hex) {
        var bigint = parseInt(hex, 16);
        var r = (bigint >> 16) & 255;
        var g = (bigint >> 8) & 255;
        var b = bigint & 255;

        return {r: r, g: g, b: b};
    }
    
    function makeChannel(a, b) {
        var num = a + Math.round((b-a)*(percent/100));
        num = Math.max(Math.min(num, 255), 0);
        return num;
    }

    color1 = hexToRgb(color1.substring(1));
    color2 = hexToRgb(color2.substring(1));
    
    var r = makeChannel(color1.r, color2.r);
    var g = makeChannel(color1.g, color2.g);
    var b = makeChannel(color1.b, color2.b);
    
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

/****************************************************/

function EventDialog(clock){
    this.clock = clock;

    this.timeNode = Element.find('setTime');
    this.textNode = Element.find('eventName');
    this.removeButton = Element.find('eventButtonRemove');
    this.form = Element.find('eventForm');
    this.prompt = Element.find('eventPrompt');
}

EventDialog.prototype = {
    show: function(angle){
        var thisObj = this;
        
        var angle = new Angle(angle);
        var markObj = new Mark(angle.get());

        this.timeNode.html(formatTime(angle.toTime()));
        this.textNode.val(markObj.title);
        
        this.removeButton.on("click", function(){
            thisObj.remove(angle);
        });
        
        this.form.on("submit", function(e){
            e.preventDefault();
            thisObj.submit(angle, thisObj.textNode.val());
            return false;
        });
    
        markObj.checked = true;
        markObj.time = angle.toTime();
        markObj.save();
    
        this.prompt.attr('class', 'visible');
        this.textNode.getNode().focus();
        
        this.clock.updateMarks();
    },
    
    remove: function(angle){
        this.close();
        
        var markObj = new Mark(angle.get());
        markObj.checked = false;
        markObj.save();
        
        this.clock.updateMarks();
    },
    
    submit: function(angle, title){
        this.close();
        
        var markObj = new Mark(angle.get());
        markObj.checked = true;
        markObj.title = title;
        markObj.time = angle.toTime();
        markObj.save();
        
        this.clock.updateMarks();
    },
    
    close: function(){
        this.prompt.attr('class', 'invisible');
    }
}

/****************************************************/

function Clock(){
    this.options = {
        markStep: 5,
        stopDelay: 200, //milliseconds
        moveSpeed: 1/4, //1 is the speed of mouse
        marksUpdateInterval: 60000, // in milliseconds
        timeUpdateInterval: 1000, // in milliseconds
        boundColors: {
            "-50": "#960018",
            "-20": "#ff0000", //angle: color (only 6-digit hex)
            "70": '#f4c430',
            "120": '#34c924',
            "300": '#2e8b57'
        }
    }
    
    this.hoursArrow = Element.find('hours');
    this.minutesArrow = Element.find('minutes');
    this.secondsArrow = Element.find('seconds');
    
    this.lastMarksUpdateTime = new Date();
    
    this.createMarks();
    
    this.activeMark = null;
    
    this.clockface = Element.find('clockface');
    var body = new Element(document.body);
    this.attachTouchEvents(this.clockface, body);
    this.attachMouseEvents(this.clockface, body);
    
    this.isMarkReady = false;
    this.stopTimeout = null;
    
    this.speedTimeBlock = Element.find('speedTimeBlock');
    this.speedTime = Element.find('speedTime');
    this.speedTimeMarker = Element.find('speedTimeMarker');
    this.speedTimeCover = Element.find('speedTimeCover');
    
    this.eventDialog = new EventDialog(this);
    
    this.touchStartAngle = null;
    this.currentAngle = null;
    
    this.initServiceButtons();
    
    this.boundAngles = [];
    for (var i in this.options.boundColors){
        this.boundAngles.push(parseInt(i));
    }
    
    this.boundAngles.sort(function(a,b){return a-b});
}

Clock.prototype = {
    start: function(){
        var thisObj = this;
    
        this.updateMarks();
        this.updateTime();
        setInterval(function(){
            thisObj.updateTime();
        }, this.options.timeUpdateInterval);
        
        this.clockface.attr('class', 'clockface active');
    },

    initServiceButtons: function(){
        var thisObj = this;
        Element.find('clearButton').on("click", function(e){
            e.preventDefault();
            localStorage.clear();
            thisObj.updateMarks();
        });
        
        Element.find('reloadButton').on("click", function(e){
            e.preventDefault();
            alert('Reload data. Coming soon...');
        });
    },

    attachTouchEvents: function(element, body){
        var thisObj = this;
        var isTouchStart = false;
    
        element.on("touchstart", function(e){
            e.preventDefault();
            
            if (isTouchStart) return;
            isTouchStart = true;
            
            var touch = e.touches[0];
            thisObj.startHighlightMark(touch.pageX, touch.pageY);
            thisObj.highlightMark(touch.pageX, touch.pageY);
        });
        
        body.on("touchmove", function(e){
            e.preventDefault();
            if (isTouchStart){
                var touch = e.touches[0];
                thisObj.highlightMark(touch.pageX, touch.pageY);
            }
        });
        
        body.on("touchend", function(){
            isTouchStart = false;
            thisObj.stopHighlightMark();
        });
    },

    attachMouseEvents: function(element, body){
        var thisObj = this;
        var isMouseDown = false;
    
        element.on("mousedown", function(e){
            e.preventDefault();
            
            if (isMouseDown) return;
            isMouseDown = true;

            thisObj.startHighlightMark(e.pageX, e.pageY);
            thisObj.highlightMark(e.pageX, e.pageY);
        });
        
        body.on("mousemove", function(e){
            e.preventDefault();
            if (isMouseDown){
                thisObj.highlightMark(e.pageX, e.pageY);
            }
        });
        
        body.on("mouseup", function(){
            isMouseDown = false;
            thisObj.stopHighlightMark();
        });
    },

    startHighlightMark: function(x, y){
        this.touchStartAngle = Angle.fromPoint(0, x, 0, y);
        this.currentAngle = new Angle(this.touchStartAngle.get());
        this.activeMark = null;
    },

    highlightMark: function(x, y){
        var thisObj = this;
        
        var angle = Angle.fromPoint(0, x, 0, y);
        var diffAngle = angle.get() - this.currentAngle.normalized();
        if (Math.abs(diffAngle) > 180) {
            var sign = diffAngle <= 0 ? 1 : -1;
            diffAngle = (360 - Math.abs(diffAngle)) * sign;
        }
        
        this.currentAngle.add(diffAngle);

        angle.set(this.touchStartAngle.get() + (this.currentAngle.get() - this.touchStartAngle.get()) * this.options.moveSpeed);
        angle.set(Math.round(angle.get() / this.options.markStep) * this.options.markStep + 180);
        angle.normalize();

        var mark = Element.find(this.getMarkId(angle.get()));
        if (!mark || (this.activeMark && mark.attr('data-angle') == this.activeMark.attr('data-angle'))) return;
        
        if (this.stopTimeout) clearTimeout(this.stopTimeout);
        
        this.isMarkReady = false;
        this.stopTimeout = setTimeout(function(){
            thisObj.setMarkReady(mark);
        }, this.options.stopDelay);
        
        this.activeMark = mark;
        
        this.showSpeedTime(angle);
    },

    stopHighlightMark: function(){
        if (!this.activeMark) return;

        if (this.isMarkReady){
            this.eventDialog.show(this.activeMark.attr('data-angle'));
        }

        this.activeMark = null;
        this.hideSpeedTime();
    },
    
    setMarkReady: function(mark){
        this.isMarkReady = true;
    },

    showSpeedTime: function(angle){
        var textTime = formatTime(angle.toTime());
        this.speedTime.text(textTime);
        this.speedTimeBlock.attr('display', 'inline');
        
        var time = new Date();
        var hourAngle = Angle.fromTimeHour(time);
        var distance = angle.distance(hourAngle);
        var color = this.getFillColor(distance);
        
        this.speedTimeMarker.transform("rotate", angle.get());
        this.speedTimeMarker.attr('fill', color);
        this.speedTimeCover.attr('fill', color);
    },

    hideSpeedTime: function(){
        this.speedTimeBlock.attr('display', 'none');
    },

    getMarkId: function(id){
        return 'mark_' + id;
    },
    
    updateTime: function(){
        var time = new Date();
        
        this.hoursArrow.transform("rotate", Angle.fromTimeHour(time).get());
        this.minutesArrow.transform("rotate", Angle.fromTimeMinute(time).get());
        this.secondsArrow.transform("rotate", Angle.fromTimeSecond(time).get());
        
        if ((time.getTime() - this.lastMarksUpdateTime.getTime()) > this.options.marksUpdateInterval){
            this.updateMarks();
        }
    },
    
    updateMarks: function(){
        var time = new Date();
        var hourAngle = Angle.fromTimeHour(time);
        
        var testTime = (new Angle(60)).toMilliseconds();
        
        for (var angle = 0; angle < 360; angle += this.options.markStep){
            var oAngle = new Angle(angle);
            
            var markObj = new Mark(oAngle.get());
            if (markObj.checked && (time.getTime() - markObj.time.getTime() > testTime)){
                markObj.checked = false;
                markObj.save();
            }
            
            var mark = Element.find(this.getMarkId(oAngle.get()));
            if (!mark) continue;
            
            var distance = oAngle.distance(hourAngle);

            mark.attr({
                "fill": markObj.checked ? this.getFillColor(distance) : '#eee',
                "fill-opacity": this.getOpacity(distance)
            });
        }
        
        this.lastMarksUpdateTime = time;
    },

    createMarks: function(){
        var clockmarkslive = Element.find('clockmarkslive');
        var touchTextureBlock = Element.find('touchTextureBlock');

        for (var angle = 0; angle < 360; angle += this.options.markStep){
            var oAngle = new Angle(angle);
            
            var textureElement = this.drawTouchTexture(oAngle);
            touchTextureBlock.append(textureElement);
            
            var markElement = this.drawMark(oAngle);
            clockmarkslive.append(markElement);
        }
    },
    
    drawMark: function(angle){
        var useId = '';
        if (!(angle.get() % Angle.config.oneHourAngle)){
            useId = 'markPrototype';
        } else {
            useId = 'smallMarkPrototype';
        }
        
        var mark = Element.use(useId);
        mark.attr({
            "id": this.getMarkId(angle.get()),
            "data-angle": angle.get()
        });
        
        mark.transform("rotate", angle.get());

        return mark;
    },
    
    drawTouchTexture: function(angle){
        var textureElement = Element.use('touchTexture');
        textureElement.transform("rotate", angle.get());
        return textureElement;
    },

    getFillColor: function(dist){
        var rgbcolor;
        var i;
        var bottomBound = false, topBound = false;
        
        for (i in this.boundAngles){
            var angle = this.boundAngles[i];
            if (dist.get() <= angle){
                topBound = angle;
                break;
            } else {
                bottomBound = angle;
            }
        }
        
        if (topBound === false) topBound = bottomBound;
        if (bottomBound === false) bottomBound = topBound;

        var percent = 100;
        if (topBound != bottomBound){
            percent = Math.abs(topBound - dist.get()) * 100 / Math.abs(topBound - bottomBound);
        }

        return getGradient(this.options.boundColors[topBound + ''], this.options.boundColors[bottomBound + ''], percent);
    },
    
    getOpacity: function(dist){
        var opacityStep = dist.get() > 0 ? 1 / 400 : 0;
        var opacity = 1 - Math.abs(dist.get()) * opacityStep;
        return opacity;
    }
}

resizeSvg();
</script>
</body>
</html>